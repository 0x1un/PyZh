:Date: 2017-04-06 10:47

.. _python_pandas:

===========================
(译)十分钟搞定pandas + 实例
===========================

:作者: wzl
:日期: 2017-04-06
:注: 欢迎fork后pull request来丰富这个文章.

.. Contents::

什么是pandas？
-------------

pandas_ : Python数据分析模块

.. _pandas: https://github.com/pandas-dev/pandas

pandas是为了解决数据分析任务而创建的，纳入了大量的库和标准数据模型，提供了高效地操作大型数据集所需的工具。

``pandas中的数据结构`` :

1. Series: 一维数组，类似于python中的基本数据结构list，区别是series只允许存储相同的数据类型，这样可以更有效的使用内存，提高运算效率。就像数据库中的列数据。

2. DataFrame: 二维的表格型数据结构。很多功能与R中的data.frame类似。可以将DataFrame理解为Series的容器。

3. Panel：三维的数组，可以理解为DataFrame的容器。

十分钟搞定pandas（译文+注释）
----------------------------

``说明`` : 本文是pandas官网 `10 Minutes to pandas <http://pandas.pydata.org/pandas-docs/stable/10min.html>`_ 的翻译。 

``引入需要的包``::

    import pandas as pd
    import numpy as np
    import matplotlib.pyplot as plt

``注``

- numpy 是一个python实现的科学计算包

- matplotlib 是一个python的2D绘图库

- 更多章节请查看 `Cookbook <http://pandas.pydata.org/pandas-docs/stable/cookbook.html#cookbook>`_

创建对象
--------
详情请查看 `数据结构介绍 <http://pandas.pydata.org/pandas-docs/stable/dsintro.html#dsintro>`_

1.通过传入一个列表来创建 `Series <http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.html#pandas.Series>`_ ，pandas会创建默认的整形指标::
    
    >>> s = pd.Series([1,3,5,np.nan,6,8])
    >>> s
    0  1
    1  3
    2  5
    3  NaN
    4  6
    5  8
    dtype: float64

2.通过传递数字数组、时间索引、列标签来创建 `DataFrame <http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.html#pandas.DataFrame>`_ ::

    >>> dates = pd.date_range('20130101',periods=6)
    >>> dates
        DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
                       '2013-01-05', '2013-01-06'],
                       dtype='datetime64[ns]', freq='D')
    
    >>> df = pd.DataFrame(np.random.randn(6,4),index=dates,columns=list('ABCD'))
    >>> df
                           A         B         C         D
        2013-01-01  0.859619 -0.545903  0.012447  1.257684
        2013-01-02  0.119622 -0.484051  0.404728  0.360880
        2013-01-03 -0.719234 -0.396174  0.635237  0.216691
        2013-01-04 -0.921692  0.876693 -0.670553  1.468060
        2013-01-05 -0.300317 -0.011320 -1.376442  1.694740
        2013-01-06 -1.903683  0.786785 -0.194179  0.177973

``注``

- np.random.randn(6,4) 即创建6行4列的随机数字数组

3.通过传递能被转换成类似结构的字典来创建DataFrame::

    >>>df2 = pd.DataFrame({'A' : 1.,
                           'B' : pd.Timestamp('20130102'), 
                           'C' : pd.Series(1,index=list(range(4)),dtype='float32'),
                           'D' : np.array([3] * 4,dtype='int32'), 
                           'E' : pd.Categorical(["test","train","test","train"]), 
                           'F' : 'foo' })

    >>> df2
           A          B  C  D      E    F
        0  1 2013-01-02  1  3   test  foo
        1  1 2013-01-02  1  3  train  foo
        2  1 2013-01-02  1  3   test  foo
        3  1 2013-01-02  1  3  train  foo

4.查看各列的 `dtypes <http://pandas.pydata.org/pandas-docs/stable/basics.html#basics-dtypes>`_ ::

    >>> df2.dtypes
        A           float64
        B    datetime64[ns]
        C           float32
        D             int32
        E          category
        F            object
        dtype: object

5.如果使用IPython，Tab会自动补全所有的属性和自定义的列，如下所示::
    
    >>> df2.<TAB>
        df2.A                   df2.boxplot
        df2.abs                 df2.C
        df2.add                 df2.clip
        df2.add_prefix          df2.clip_lower
        df2.add_suffix          df2.clip_upper
        df2.align               df2.columns
        df2.all                 df2.combine
        df2.any                 df2.combineAdd
        df2.append              df2.combine_first
        df2.apply               df2.combineMult
        df2.applymap            df2.compound
        df2.as_blocks           df2.consolidate
        df2.asfreq              df2.convert_objects
        df2.as_matrix           df2.copy
        df2.astype              df2.corr
        df2.at                  df2.corrwith
        df2.at_time             df2.count
        df2.axes                df2.cov
        df2.B                   df2.cummax
        df2.between_time        df2.cummin
        df2.bfill               df2.cumprod
        df2.blocks              df2.cumsum
        df2.bool                df2.D

    可以看到，A、B、C、D列均通过Tab自动生成

查看数据
--------
详情请查看 `基本功能 <http://pandas.pydata.org/pandas-docs/stable/basics.html#basics>`_ 

1.查看DataFrame头部&尾部数据::
    >>> df.head()
                           A         B         C         D
        2013-01-01  0.859619 -0.545903  0.012447  1.257684
        2013-01-02  0.119622 -0.484051  0.404728  0.360880
        2013-01-03 -0.719234 -0.396174  0.635237  0.216691
        2013-01-04 -0.921692  0.876693 -0.670553  1.468060
        013-01-05 -0.300317 -0.011320 -1.376442  1.694740
    >>> df.tail(3)
                           A         B         C         D
        2013-01-04 -0.921692  0.876693 -0.670553  1.468060
        2013-01-05 -0.300317 -0.011320 -1.376442  1.694740
        2013-01-06 -1.903683  0.786785 -0.194179  0.177973

2.查看索引、列、和数组数据::
    >>> df.index
        DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',
                       '2013-01-05', '2013-01-06'],
                        dtype='datetime64[ns]', freq='D')
    >>> df.columns
        Index([u'A', u'B', u'C', u'D'], dtype='object')
    >>> df.values
        array([[ 0.85961861, -0.54590304,  0.01244705,  1.25768432],
        [ 0.11962178, -0.4840508 ,  0.40472795,  0.36088029],
        [-0.7192337 , -0.39617432,  0.63523701,  0.21669124],
        [-0.92169244,  0.87669275, -0.67055318,  1.46806034],
        [-0.30031679, -0.01132035, -1.37644224,  1.69474031],
        [-1.90368258,  0.78678454, -0.19417942,  0.17797326]])

3.查看数据的快速统计结果::
    >>> df.describe()
                      A         B         C         D
        count  6.000000  6.000000  6.000000  6.000000
        mean  -0.477614  0.037671 -0.198127  0.862672
        std    0.945047  0.643196  0.736736  0.685969
        min   -1.903683 -0.545903 -1.376442  0.177973
        25%   -0.871078 -0.462082 -0.551460  0.252739
        50%   -0.509775 -0.203747 -0.090866  0.809282
        75%    0.014637  0.587258  0.306658  1.415466
        max    0.859619  0.876693  0.635237  1.694740

4.对数据进行行列转换::
    >>> df.T
           2013-01-01  2013-01-02  2013-01-03  2013-01-04  2013-01-05  2013-01-06
        A    0.859619    0.119622   -0.719234   -0.921692   -0.300317   -1.903683
        B   -0.545903   -0.484051   -0.396174    0.876693   -0.011320    0.786785
        C    0.012447    0.404728    0.635237   -0.670553   -1.376442   -0.194179
        D    1.257684    0.360880    0.216691    1.468060    1.694740    0.177973

5.按 `axis <http://stackoverflow.com/questions/22149584/what-does-axis-in-pandas-mean>`_ 排序::
    >>> df.sort_index(axis=1, ascending=False)
                           D         C         B         A
        2013-01-01  1.257684  0.012447 -0.545903  0.859619
        2013-01-02  0.360880  0.404728 -0.484051  0.119622
        2013-01-03  0.216691  0.635237 -0.396174 -0.719234
        2013-01-04  1.468060 -0.670553  0.876693 -0.921692
        2013-01-05  1.694740 -1.376442 -0.011320 -0.300317
        2013-01-06  0.177973 -0.194179  0.786785 -1.903683

6.按值排序::
    >>> df.sort_values(by='B')
                           A         B         C         D
        2013-01-01  0.859619 -0.545903  0.012447  1.257684
        2013-01-02  0.119622 -0.484051  0.404728  0.360880
        2013-01-03 -0.719234 -0.396174  0.635237  0.216691
        2013-01-05 -0.300317 -0.011320 -1.376442  1.694740
        2013-01-06 -1.903683  0.786785 -0.194179  0.177973
        2013-01-04 -0.921692  0.876693 -0.670553  1.468060

选择数据
--------

``注意``:虽然标准的Python/Numpy表达式是直观且可用的，但是我们推荐使用优化后的pandas方法,例如:.at,.iat,.loc,.iloc以及.ix
详情请查看: `Indexing and Selecting Data <http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing>`_ 和 `MultiIndex / Advanced Indexing <http://pandas.pydata.org/pandas-docs/stable/advanced.html#advanced>`_

- 获取
1.选择一列，返回Series，相当于df.A::
    >>> df['A']
        2013-01-01    0.859619
        2013-01-02    0.119622
        2013-01-03   -0.719234
        2013-01-04   -0.921692
        2013-01-05   -0.300317
        2013-01-06   -1.903683
        Freq: D, Name: A, dtype: float64

2.通过[]选择，即对行进行切片::
    >>> df[0:3]
                           A         B         C         D
        2013-01-01  0.859619 -0.545903  0.012447  1.257684
        2013-01-02  0.119622 -0.484051  0.404728  0.360880
        2013-01-03 -0.719234 -0.396174  0.635237  0.216691

- 标签式选择
1.通过标签获取交叉区域::
    >>> df.loc[dates[0]]
        A    0.859619
        B   -0.545903
        C    0.012447
        D    1.257684
        Name: 2013-01-01 00:00:00, dtype: float64
``注``:即获取时间为2013-01-01的数据

2.通过标签获取多轴数据::
    >>> df.loc[:,['A','B']]
                          A         B
        2013-01-01  0.859619 -0.545903
        2013-01-02  0.119622 -0.484051
        2013-01-03 -0.719234 -0.396174
        2013-01-04 -0.921692  0.876693
        2013-01-05 -0.300317 -0.011320
        2013-01-06 -1.903683  0.786785

3.标签切片::
    >>> df.loc['20130102':'20130104',['A','B']]
                           A         B
        2013-01-02  0.119622 -0.484051
        2013-01-03 -0.719234 -0.396174
        2013-01-04 -0.921692  0.876693

4.对返回的对象缩减维度::
    >>> df.loc['20130102',['A','B']]
        A    0.119622
        B   -0.484051
        Name: 2013-01-02 00:00:00, dtype: float64

5.获取单个值::
    >>> df.loc[dates[0],'A']
        0.85961861159875042

6.快速访问单个标量（同5）::
    >>> df.at[dates[0],'A']
        0.85961861159875042

``注``:loc通过行标签获取行数据，iloc通过行号获取行数据

- 位置式选择

详情请查看 `通过位置选择 <http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-integer>`_

1.通过数值选择::
    >>> df.iloc[3]
        A   -0.921692
        B    0.876693
        C   -0.670553
        D    1.468060
        Name: 2013-01-04 00:00:00, dtype: float64

2.通过数值切片::
    >>> df.iloc[3:5,0:2]
                           A         B
        2013-01-04 -0.921692  0.876693
        2013-01-05 -0.300317 -0.011320
``注``:左开右闭

3.通过指定列表位置::
    >>> df.iloc[[1,2,4],[0,2]]
                           A         C
        2013-01-02  0.119622  0.404728
        2013-01-03 -0.719234  0.635237
        2013-01-05 -0.300317 -1.376442

4.对行切片::
    >>> df.iloc[1:3,:]
                           A         B         C         D
        2013-01-02  0.119622 -0.484051  0.404728  0.360880
        2013-01-03 -0.719234 -0.396174  0.635237  0.216691

5.对列切片::
    >>> df.iloc[:,1:3]
                           B         C
        2013-01-01 -0.545903  0.012447
        2013-01-02 -0.484051  0.404728
        2013-01-03 -0.396174  0.635237
        2013-01-04  0.876693 -0.670553
        2013-01-05 -0.011320 -1.376442
        2013-01-06  0.786785 -0.194179

6.获取特定值::
    >>> df.iloc[1,1]
        -0.48405080229207309

7.快速访问某个标量（同6）::
    >>> df.iat[1,1]
        -0.48405080229207309

- Boolean索引
1.通过某列选择数据::
    >>> df[df.A > 0]
                           A         B         C         D
        2013-01-01  0.859619 -0.545903  0.012447  1.257684
        2013-01-02  0.119622 -0.484051  0.404728  0.360880

2.通过where选择数据::
    >>> df[df > 0]
                           A         B         C         D
        2013-01-01  0.859619       NaN  0.012447  1.257684
        2013-01-02  0.119622       NaN  0.404728  0.360880
        2013-01-03       NaN       NaN  0.635237  0.216691
        2013-01-04       NaN  0.876693       NaN  1.468060
        2013-01-05       NaN       NaN       NaN  1.694740
        2013-01-06       NaN  0.786785       NaN  0.177973

3.通过 `isin() <http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.isin.html#pandas.Series.isin>`_ 过滤数据::
    >>> df2 = df.copy()
    >>> df2['E'] = ['one', 'one','two','three','four','three']
    >>> df2
                       A         B         C         D      E
        2013-01-01  0.859619 -0.545903  0.012447  1.257684    one
        2013-01-02  0.119622 -0.484051  0.404728  0.360880    one
        2013-01-03 -0.719234 -0.396174  0.635237  0.216691    two
        2013-01-04 -0.921692  0.876693 -0.670553  1.468060  three
        2013-01-05 -0.300317 -0.011320 -1.376442  1.694740   four
        2013-01-06 -1.903683  0.786785 -0.194179  0.177973  three
    >>> df2[df2['E'].isin(['two','four'])]
                       A         B         C         D     E
        2013-01-03 -0.719234 -0.396174  0.635237  0.216691   two
        2013-01-05 -0.300317 -0.011320 -1.376442  1.694740  four

- 设置
1.新增一列数据::
    >>> s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20130102', periods=6))
    >>> s1
        2013-01-02    1
        2013-01-03    2
        2013-01-04    3
        2013-01-05    4
        2013-01-06    5
        2013-01-07    6
        Freq: D, dtype: int64
    >>> df['F'] = s1

2.通过标签更新值::
    >>> df.at[dates[0],'A'] = 0

3.通过位置更新值::
    >>> df.iat[0,1] = 0

4.通过数组更新一列值::
    >>> df.loc[:,'D'] = np.array([5] * len(df))

上面几步操作的结果::
    >>> df
                           A         B         C  D   F
        2013-01-01  0.000000  0.000000  0.012447  5 NaN
        2013-01-02  0.119622 -0.484051  0.404728  5   1
        2013-01-03 -0.719234 -0.396174  0.635237  5   2
        2013-01-04 -0.921692  0.876693 -0.670553  5   3
        2013-01-05 -0.300317 -0.011320 -1.376442  5   4
        2013-01-06 -1.903683  0.786785 -0.194179  5   5

5.通过where更新值::
    >>> df2 = df.copy()
    >>> df2[df2 > 0] = -df2
    >>> df2
                       A         B         C  D   F
        2013-01-01  0.000000  0.000000 -0.012447 -5 NaN
        2013-01-02 -0.119622 -0.484051 -0.404728 -5  -1
        2013-01-03 -0.719234 -0.396174 -0.635237 -5  -2
        2013-01-04 -0.921692 -0.876693 -0.670553 -5  -3
        2013-01-05 -0.300317 -0.011320 -1.376442 -5  -4
        2013-01-06 -1.903683 -0.786785 -0.194179 -5  -5    

缺失数据处理
------------


相关操作
--------


合并
----

分组
----

重塑
----

时间序列
--------

分类
----

绘图
----

获取数据 写入\导出
------------------

小陷阱
------

pandas实战
----------
